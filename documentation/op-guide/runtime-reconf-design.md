# 运行时重配置的设计

> 注：内容翻译自 [Design of runtime reconfiguration](https://github.com/coreos/etcd/blob/master/Documentation/op-guide/runtime-reconf-design.md)

在分布式系统中，运行时重配置是最困难和易出错的，尤其是强一致性的系统如 etcd 中。

继续阅读来了解关于 etcd 的运行时重配置命令的设计和我们如何解决这些问题。

## 两阶段配置变更保持集群安全

在etcd中，为了安全每个运行时重配置必须通过 [两阶段][add-member]。例如，为了添加成员，首先通知集群新配置然后再启动新成员。

阶段 1 - 通知集群新配置

为了添加成员到 etcd 集群，发起一个 API 调用来请求添加一个新成员到集群。这是添加新成员到现有集群的唯一方法。当集群同意配置变更时 API 调用返回。

阶段 2 - 启动新成员

为了将 etcd 成员加入已有的集群，指定正确的 `initial-cluster` 并设置 `initial-cluster-state` 为 `existing`。当成员启动时, 它会与已有的集群成员建立连接，并验证当前集群配置和 `initial-cluster` 匹配。当新成员成功启动时，集群配置就到达期待的状态。

通过将过程拆分为两个分离的阶段，强制用户意识到对集群成员的修改。这实际给了用户更多灵活性并让事情容易推导。例如，如果试图使用和集群中现有成员相同的ID添加新成员，这个行为将在阶段1期间失败，而不影响运行中的集群。类似的保护措施方式错误添加成员。

如果没有明确的针对集群成员修改的工作流，etcd 将容易受到集群成员修改的影响。例如，如果 etcd 运行在初始化系统例如 systemd 上，etcd 在通过成员API移除之后将被 systemd 重启，并试图在启动时重新加入集群。这个循环在每次成员被通过API删除时继续，而 systemd 设置为在失败之后重启 etcd，这是出乎意料的。

我们期待极少进行运行时重配置操作。我们决定让它保持操作明确和用户驱动，以保证配置安全和集群总是在明确控制下平稳运行。

## 法定人数永久丢失需要新集群

如果集群永久丢失了它的成员的多数，需要从旧有的数据目录启动新的集群来恢复之前的状态。

从已有集群中强制删除失败成员来恢复是完全可能的。但是，我们决定不支持这个方法，因为它绕开了正常的一致性提交阶段，这是不安全的。如果要删除的成员并实际上并没有死亡或者是通过在同一个集群中的不同成员强制删除，etcd 最终将会形成多个具有相同 clusterID 的集群。这非常危险且之后难于调试/修改。

正确部署时，永久多数丢失的可能性非常低。但是它是一个足够严重的问题，需要引起注意。强烈建议阅读 [灾难恢复文档][disaster-recovery]，并为生产环境中的永久多数丢失做好预案。

## 不要为运行时重配置使用公开发现服务（discovery service）

公开发现服务(discovery service)仅仅应该用于启动集群。要往已有集群中添加成员，使用运行时重配置API。

发现服务设计用于在云环境下启动 etcd 集群，当所有成员的 IP 地址无法提前得知时。在成功启动集群后，所有成员的 IP 地址都已知。严格说，发现服务应该不再需要。

看上去使用公开发现服务是做运行时重配置的捷径，毕竟发现服务已经有所有集群配置信息。但是，依赖公开发现服务将带来问题：

1. 它为集群的完整生命周期引入额外依赖，而不仅仅是启动期间。如果集群和公开发现服务之间网络存在问题，集群将为此受影响。

2. 公开发现服务必须考虑在生命周期中集群的正确运行时配置。它必须提供安全机制来避免错误操作，而这是很困难的。

3. 公开发现服务必须保持数以万计的集群配置。我们的公开发现服务没有为这种负载做好准备。

想要拥有支持运行时重配置的发现服务，最佳选择是搭建一个私有服务。

[add-member]: runtime-configuration.md#添加新成员
[disaster-recovery]: recovery.md


