# 数据模型

> 注： 内容翻译自 [data model](https://github.com/coreos/etcd/blob/master/Documentation/learning/data_model.md)

etcd设计用于可靠得存储更新不频繁的数据，并提供可靠的 watch 查询。etcd暴露键值对的先前版本，从而支持廉价的快照和观察历史事件("time travel queries")。对于这些使用场景，持久化，多版本，并发控制的数据模型是非常适合的。

ectd使用多版本[持久化](https://en.wikipedia.org/wiki/Persistent_data_structure)键值存储来存储数据。当键值对的值被新的数据替代时，持久化键值存储保存先前版本的数据。键值存储事实上是不可变的；它的操作不会原地更新结构，取而代之的是生成一个新的更新后的结构。在修改之后，key的所有先前版本还是可以访问和观察的。为了防止随着时间的增长，维护的老版本数据导致存储无限增长，存储应该压缩来丢弃被替代的旧版本数据。

### 逻辑视图

存储的逻辑视图是一个扁平的二进制键空间。键空间对 key 按字典排序进行索引，因此范围查询是廉价的。

键空间维护多个版本。每个原子更改操作（类如，一个事务操作可能包含多个操作）在键空间上创建一个新的修订版本。先前版本持有的所有数据保持不变。key 的旧版本还可以通过先前修订版本访问。同样的，修订版本也是被索引的；在修订版本上搜索(带 watcher)是高效的。一旦存储被压缩来腾出空间，在压缩修订版本之前的修订版本被移除。

key的生命周期跨越一代(spans a generation)。每个key可以有一代或者多代。创建key增加了key的代，如果key从未存在则从1开始。删除一个key产生一个key的墓碑，结束key的当前代。key的每次改动创建key的一个新的版本。一旦压缩发生，任何在给定修订版本之前结束的时代将被删除，而在压缩修订版本之前设置的值，除最后一个外，都将被移除。

### 物理视图

etcd以持久化 [b+tree](https://en.wikipedia.org/wiki/B%2B_tree) 的方式存储物理数据。为了效率，每个版本仅存储它相对于前一版本的增量数据。单个修订版本可能对应到tree上的多个key。

键值对的key是三元数组(major, sub, type)。Major是key的存储修订版本。Sub区分同一个修订版本的不同key。Type是用于特别值(例如，`t`，如果值包含一个墓碑)的可选后缀。键值对的值包含对前一个版本的改动，因此是相对于前一个版本的增量值。b+tree 以 key 的字节词典顺序排序。版本增量的查找(Ranged lookups)很快；这样可以快速发现版本之间的修改。压缩会删除过期的键值对。

etcd也会在内存中保存 [btree](https://en.wikipedia.org/wiki/B-tree) 索引来加速 key 的范围查询。在btree索引的key是持久化存储的key；值是指向持久化 b+tree 的指针。压缩删除无效指针。


