# 数据模型

> 注： 内容翻译自 [data model](https://github.com/coreos/etcd/blob/master/Documentation/learning/data_model.md)

etcd设计用于可靠存储不频繁更新的数据，并提供可靠的观察查询。etcd暴露键值对的先前版本来支持不昂贵的快速和观察历史事件("time travel queries")。对于这些使用场景，持久化，多版本，并发控制的数据模型是非常适合的。

ectd使用多版本持久化键值存储来存储数据。当键值对的值被新的数据替代时，持久化键值存储保存先前版本的键值对。键值存储事实上是不可变的;它的操作不会就地更新结构，替代的是总是生成一个新的更新后的结构。在修改之后，key的所有先前版本还是可以访问和观察的。为了防止随着时间的过去为了维护老版本导致数据存储无限增长，存储应该压缩来脱离被替代的数据的最旧的版本。

### 逻辑视图

存储的逻辑视图是一个扁平的二进制键空间。键空间有一个在byte string 键上的语义排序的索引，因此范围查询不是太昂贵。

键空间维护多个版本。每个原子变化操作(类如，一个事务操作可能包含多个操作)在键空间上创建一个新的修订版本。先前版本持有的所有数据保持不变。key的旧有版本还可以通过先前修订版本访问。同样的，修订版本也是被索引的;在修订版本上搜索(带观察者)是高效的。一旦存储被压缩来恢复空间，在压缩修订版本之前的修订版本被移除。

key的生命周期跨越一代(spans a generation)。每个key可以有一代或者多代。创建key增加了key的代，如果key从未存在则从1开始。删除一个key产生一个key的墓碑，结束key的当前时代。key的每次改动创建key的一个新的版本。一旦压缩发生，任何在给定修订版本之前结束的时代将被删除，而在压缩修订版本之前设置的值，除最后一个外，都将被移除。

### 物理视图

etcd以持久性 [b+tree](https://en.wikipedia.org/wiki/B%2B_tree) 键值对的方式存储物理数据。存储的状态的每个修订版本仅仅包含和它的前一个修订版本的增量以求高效。单个修订版本可能对应到tree上的多个key。

键值对的key是三元数组(major, sub, type)。Major是持有key的存储修订版本。Sub区分同一个修订版本的不同key。Type是用于特别值(例如，`t`，如果值包含一个墓碑)的可选后缀。键值对的值包含对前一个修订版本的改动，例如对前一个修订版本的增量。b+tree以key的词典字节顺序排序。在修订版本增量上的延伸查找(Ranged lookups)很快。这样可以快速发送从一个特定修订版本到另一个的改变。压缩删除过期的键值对。

etcd也保持内存中的第二btree索引来加速key的范围查询。在btree索引中的key是存储暴露给用户的key。值是到持久化b+tree修改的指针。压缩删除死指针。


